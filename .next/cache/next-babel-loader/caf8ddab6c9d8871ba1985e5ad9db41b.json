{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport createRecord from \"../queries/crud/createRecord\";\nimport deleteRecord from \"../queries/crud/deleteRecord\";\nimport query from \"../queries/crud/query\";\nimport updateRecord from \"../queries/crud/updateRecord\";\nimport { flow } from \"mobx-state-tree\";\nimport { isLateType, isUnionType, types } from \"mobx-state-tree\";\nexport default (opt => {\n  let primaryKey = !opt.primaryKey ? \"id\" : opt.primaryKey;\n  let columns = {};\n\n  for (let i in opt.columns) {\n    const c = opt.columns[i];\n\n    if (typeof c !== typeof types.maybeNull) {\n      columns[i] = types.maybeNull(c);\n    } else {\n      columns[i] = c;\n    }\n  }\n\n  const recordResult = types.model(_objectSpread({}, columns, {\n    _meta: types.optional(types.string, _JSON$stringify({\n      primaryKey: primaryKey,\n      tableName: opt.tableName\n    })),\n    loading: types.optional(types.boolean, false),\n    errors: types.optional(types.array(types.string), []),\n    isSaved: types.optional(types.boolean, false)\n  })).views(self => ({\n    get isNewRecord() {\n      return !self[primaryKey];\n    },\n\n    get rawData() {\n      const col = _Object$keys(opt.columns);\n\n      const result = {};\n      col.forEach(key => {\n        if (self[key] !== null) {\n          result[key] = self[key];\n        }\n      });\n      return result;\n    }\n\n  })).actions(self => {\n    let actions = {};\n\n    if (opt.actions) {\n      actions = opt.actions(self);\n    }\n\n    return _objectSpread({}, actions, {\n      set: function (key, value) {\n        if (typeof key === \"string\") {\n          self[key] = value;\n\n          if (self[key] !== value) {\n            self.isSaved = false;\n          }\n        } else {\n          for (let i in key) {\n            self[i] = key[i];\n          }\n\n          self.isSaved = false;\n        }\n      },\n      save: flow(function* () {\n        self.validate();\n\n        if (self.errors.length === 0) {\n          if (self.isNewRecord) {\n            self.set(\"loading\", true);\n            const id = yield createRecord(opt.tableName, self.rawData, {\n              primaryKey\n            });\n\n            if (id) {\n              self.set(primaryKey, id);\n              self.set(\"isSaved\", true);\n            }\n\n            self.set(\"loading\", false);\n          } else {\n            yield updateRecord(opt.tableName, self.rawData, {\n              primaryKey\n            });\n          }\n        }\n      }),\n      validate: function () {\n        if (opt.validations) {\n          const validations = opt.validations;\n          const errors = [];\n\n          _Object$keys(validations).forEach(key => {\n            if (validations[key] === \"required\") {\n              if (self[key] === undefined || self[key] === null || self[key] === \"\") {\n                errors.push(`${key} is required.`);\n              }\n            }\n          });\n\n          self.errors = errors;\n        }\n      },\n      load: flow(function* () {\n        if (!self.isNewRecord) {\n          yield self.find({\n            [primaryKey]: self[primaryKey]\n          });\n        }\n      }),\n      find: flow(function* (where, findopt) {\n        self.set(\"loading\", true);\n\n        try {\n          const columns = _Object$keys(opt.columns).map(c => {\n            if (isLateType(opt.columns[c]) || isUnionType(opt.columns[c])) {\n              let query = ``;\n              const col = opt.columns[c];\n              if (col._subType) query = col._subType.properties.query._defaultValue;\n\n              if (_Array$isArray(col._types)) {\n                col._types.forEach(e => {\n                  if (isLateType(e)) {\n                    if (e._subType) {\n                      query = `{ ${e._subType.columns.join(\"\\n\")} }`;\n                    }\n                  }\n                });\n              }\n\n              if (findopt && findopt.query && findopt.query[c]) {\n                query = findopt.query[c];\n              }\n\n              if (query) {\n                return `${c} ${query}`;\n              } else {\n                return ``;\n              }\n            }\n\n            return c;\n          });\n\n          let record = (yield query(opt.tableName, columns, {\n            where\n          })) || {};\n\n          for (let c in record) {\n            const value = record[c];\n\n            if (_Array$isArray(value) && isLateType(opt.columns[c])) {\n              self.set(c, {\n                list: value,\n                loading: false\n              });\n            } else {\n              self.set(c, value);\n            }\n          }\n\n          self.set(\"isSaved\", true);\n          self.set(\"loading\", false);\n        } catch (e) {\n          self.set(\"loading\", false);\n          console.warn(e);\n        }\n      }),\n      delete: flow(function* () {\n        try {\n          const row = yield deleteRecord(opt.tableName, self.rawData, {\n            primaryKey\n          });\n\n          _Object$keys(opt.columns).forEach(c => {\n            if (self[c] !== null) {\n              self.set(c, null);\n            }\n          });\n        } catch (e) {}\n      })\n    });\n  });\n  recordResult.columns = _Object$keys(columns);\n  return recordResult;\n});","map":{"version":3,"sources":["/Users/riz/Documents/edumatis-web/libs/utils/Record.ts"],"names":["createRecord","deleteRecord","query","updateRecord","flow","isLateType","isUnionType","types","opt","primaryKey","columns","i","c","maybeNull","recordResult","model","_meta","optional","string","tableName","loading","boolean","errors","array","isSaved","views","self","isNewRecord","rawData","col","result","forEach","key","actions","set","value","save","validate","length","id","validations","undefined","push","load","find","where","findopt","map","_subType","properties","_defaultValue","_types","e","join","record","list","console","warn","delete","row"],"mappings":"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","sourcesContent":["import createRecord from \"@app/libs/queries/crud/createRecord\";\nimport deleteRecord from \"@app/libs/queries/crud/deleteRecord\";\nimport query from \"@app/libs/queries/crud/query\";\nimport updateRecord from \"@app/libs/queries/crud/updateRecord\";\nimport { flow } from \"mobx-state-tree\";\nimport { IModelType, isLateType, isUnionType, ModelPropertiesDeclaration, ModelPropertiesDeclarationToProperties, types } from \"mobx-state-tree\";\n\nexport default <P extends ModelPropertiesDeclaration = {}>(opt: {\n  tableName: string;\n  primaryKey?: string;\n  validations?: {\n    [key: string]: \"required\";\n  };\n  columns: P;\n  actions?: (\n    self: any\n  ) => {\n    [key: string]: any;\n  };\n}): IModelType<\n  ModelPropertiesDeclarationToProperties<P>,\n  {\n    set: (key: string | any, value?: any) => void;\n    save: () => void;\n    load: () => void;\n    validate: () => void;\n    delete: () => void;\n    find: (where: { [key: string]: any }, findopt?: { query?: any }) => void;\n  }\n> => {\n  let primaryKey = !opt.primaryKey ? \"id\" : opt.primaryKey;\n  let columns: any = {};\n\n  for (let i in opt.columns) {\n    const c = opt.columns[i];\n    if (typeof c !== typeof types.maybeNull) {\n      columns[i] = types.maybeNull(c as any);\n    } else {\n      columns[i] = c;\n    }\n  }\n\n  const recordResult: any = types\n    .model({\n      ...columns,\n      _meta: types.optional(\n        types.string,\n        JSON.stringify({\n          primaryKey: primaryKey,\n          tableName: opt.tableName\n        })\n      ),\n      loading: types.optional(types.boolean, false),\n      errors: types.optional(types.array(types.string), []),\n      isSaved: types.optional(types.boolean, false)\n    })\n    .views((self: any) => ({\n      get isNewRecord() {\n        return !self[primaryKey];\n      },\n      get rawData() {\n        const col = Object.keys(opt.columns);\n        const result: any = {};\n        col.forEach(key => {\n          if (self[key] !== null) {\n            result[key] = self[key];\n          }\n        });\n        return result;\n      }\n    }))\n    .actions((self: any) => {\n      let actions = {};\n\n      if (opt.actions) {\n        actions = opt.actions(self);\n      }\n\n      return {\n        ...actions,\n        set: function(key: string | any, value?: any) {\n          if (typeof key === \"string\") {\n            self[key] = value;\n            if (self[key] !== value) {\n              self.isSaved = false;\n            }\n          } else {\n            for (let i in key) {\n              self[i] = key[i];\n            }\n            self.isSaved = false;\n          }\n        },\n        save: flow(function*() {\n          self.validate();\n          if (self.errors.length === 0) {\n            if (self.isNewRecord) {\n              self.set(\"loading\", true);\n              const id = yield createRecord(opt.tableName, self.rawData, {\n                primaryKey\n              });\n              if (id) {\n                self.set(primaryKey, id);\n                self.set(\"isSaved\", true);\n              }\n              self.set(\"loading\", false);\n            } else {\n              yield updateRecord(opt.tableName, self.rawData, {\n                primaryKey\n              });\n            }\n          }\n        }),\n        validate: function() {\n          if (opt.validations) {\n            const validations = opt.validations;\n            const errors: string[] = [];\n            Object.keys(validations).forEach(key => {\n              if (validations[key] === \"required\") {\n                if (\n                  self[key] === undefined ||\n                  self[key] === null ||\n                  self[key] === \"\"\n                ) {\n                  errors.push(`${key} is required.`);\n                }\n              }\n            });\n\n            self.errors = errors;\n          }\n        },\n        load: flow(function*() {\n          if (!self.isNewRecord) {\n            yield self.find({ [primaryKey]: self[primaryKey] });\n          }\n        }),\n        find: flow(function*(\n          where: { [key: string]: any },\n          findopt?: { query?: any }\n        ) {\n          self.set(\"loading\", true);\n          try {\n            const columns = Object.keys(opt.columns).map(c => {\n              if (\n                isLateType(opt.columns[c] as any) ||\n                isUnionType(opt.columns[c] as any)\n              ) {\n                let query = ``;\n                const col: any = opt.columns[c];\n                if (col._subType)\n                  query = col._subType.properties.query._defaultValue;\n\n                if (Array.isArray(col._types)) {\n                  col._types.forEach((e: any) => {\n                    if (isLateType(e)) {\n                      if (e._subType) {\n                        query = `{ ${e._subType.columns.join(\"\\n\")} }`;\n                      }\n                    }\n                  });\n                }\n\n                if (findopt && findopt.query && findopt.query[c]) {\n                  query = findopt.query[c];\n                }\n\n                if (query) {\n                  return `${c} ${query}`;\n                } else {\n                  return ``;\n                }\n              }\n              return c;\n            });\n\n            let record = (yield query(opt.tableName, columns, {\n              where\n            })) || {};\n\n            for (let c in record) {\n              const value = record[c];\n              if (Array.isArray(value) && isLateType(opt.columns[c] as any)) {\n                self.set(c, {\n                  list: value,\n                  loading: false\n                });\n              } else {\n                self.set(c, value);\n              }\n            }\n            self.set(\"isSaved\", true);\n            self.set(\"loading\", false);\n          } catch (e) {\n            self.set(\"loading\", false);\n            console.warn(e);\n          }\n        }),\n        delete: flow(function*() {\n          try {\n            const row = yield deleteRecord(opt.tableName, self.rawData, {\n              primaryKey\n            });\n\n            Object.keys(opt.columns).forEach(c => {\n              if (self[c] !== null) {\n                self.set(c, null);\n              }\n            });\n          } catch (e) {}\n        })\n      };\n    });\n\n  recordResult.columns = Object.keys(columns);\n  return recordResult;\n};\n"]},"metadata":{},"sourceType":"module"}