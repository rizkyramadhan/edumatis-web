{"ast":null,"code":"import _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport config from \"../../config\";\nimport { checkSession } from \"../user/checkSession\";\nexport default (async (table, data, options) => {\n  const opt = _objectSpread({}, {\n    useSession: true,\n    debug: false,\n    primaryKey: \"id\"\n  }, options);\n\n  const postData = {};\n\n  for (let i in data) {\n    if (i === opt.primaryKey || i.endsWith(\"_aggregate\")) {\n      continue;\n    }\n\n    postData[i] = data[i];\n  }\n\n  const gql = `mutation update($data:${table}_set_input!) {\n    update_${table}(\n      where: {${opt.primaryKey}: {_eq: \"${data[opt.primaryKey]}\"}},\n      _set: $data\n    ) {\n      returning {\n        ${opt.primaryKey}\n      }\n    }\n  }`;\n\n  if (opt && opt.debug) {\n    console.log(gql, data);\n  }\n\n  let headers = {\n    \"Content-Type\": \"application/json\"\n  };\n\n  if (opt.useSession) {\n    const session = await checkSession();\n    headers[\"X-Hasura-Session-Id\"] = session.id;\n\n    if (!session) {\n      return false;\n    }\n  }\n\n  const response = await fetch(config.url, {\n    method: \"POST\",\n    body: _JSON$stringify({\n      operationName: \"update\",\n      query: gql,\n      variables: {\n        data: postData\n      }\n    }),\n    headers\n  });\n  const json = await response.json();\n\n  if (response.status !== 200) {\n    if (json && json.errors && json.errors[0] && json.errors[0].message) {\n      throw `\n(Update Record Failed) ${json.errors[0].message} \n\nGraphQL Mutation:\n${gql}\n\nData: \n${_JSON$stringify(data, null, 2).replace(/\"/gi, \"'\")}\n        `.trim();\n    }\n\n    return null;\n  }\n\n  return json;\n});","map":{"version":3,"sources":["/Users/riz/Documents/edumatis-web/libs/queries/crud/updateRecord.ts"],"names":["config","checkSession","table","data","options","opt","useSession","debug","primaryKey","postData","i","endsWith","gql","console","log","headers","session","id","response","fetch","url","method","body","operationName","query","variables","json","status","errors","message","replace","trim"],"mappings":";;AAAA,OAAOA,MAAP;AACA,SAASC,YAAT;AAQA,gBAAe,OAAOC,KAAP,EAAsBC,IAAtB,EAAiCC,OAAjC,KAAoD;AACjE,QAAMC,GAAG,qBACJ;AAAEC,IAAAA,UAAU,EAAE,IAAd;AAAoBC,IAAAA,KAAK,EAAE,KAA3B;AAAkCC,IAAAA,UAAU,EAAE;AAA9C,GADI,EAEJJ,OAFI,CAAT;;AAKA,QAAMK,QAAa,GAAG,EAAtB;;AACA,OAAK,IAAIC,CAAT,IAAcP,IAAd,EAAoB;AAClB,QAAIO,CAAC,KAAKL,GAAG,CAACG,UAAV,IAAwBE,CAAC,CAACC,QAAF,CAAW,YAAX,CAA5B,EAAsD;AACpD;AACD;;AACDF,IAAAA,QAAQ,CAACC,CAAD,CAAR,GAAcP,IAAI,CAACO,CAAD,CAAlB;AACD;;AAED,QAAME,GAAG,GAAI,yBAAwBV,KAAM;aAChCA,KAAM;gBACHG,GAAG,CAACG,UAAW,YAAWL,IAAI,CAACE,GAAG,CAACG,UAAL,CAAiB;;;;UAIrDH,GAAG,CAACG,UAAW;;;IANvB;;AAWA,MAAIH,GAAG,IAAIA,GAAG,CAACE,KAAf,EAAsB;AACpBM,IAAAA,OAAO,CAACC,GAAR,CAAYF,GAAZ,EAAiBT,IAAjB;AACD;;AAED,MAAIY,OAAY,GAAG;AACjB,oBAAgB;AADC,GAAnB;;AAGA,MAAIV,GAAG,CAACC,UAAR,EAAoB;AAClB,UAAMU,OAAO,GAAG,MAAMf,YAAY,EAAlC;AACAc,IAAAA,OAAO,CAAC,qBAAD,CAAP,GAAiCC,OAAO,CAACC,EAAzC;;AACA,QAAI,CAACD,OAAL,EAAc;AACZ,aAAO,KAAP;AACD;AACF;;AAED,QAAME,QAAkB,GAAG,MAAMC,KAAK,CAACnB,MAAM,CAACoB,GAAR,EAAa;AACjDC,IAAAA,MAAM,EAAE,MADyC;AAEjDC,IAAAA,IAAI,EAAE,gBAAe;AACnBC,MAAAA,aAAa,EAAE,QADI;AAEnBC,MAAAA,KAAK,EAAEZ,GAFY;AAGnBa,MAAAA,SAAS,EAAE;AACTtB,QAAAA,IAAI,EAAEM;AADG;AAHQ,KAAf,CAF2C;AASjDM,IAAAA;AATiD,GAAb,CAAtC;AAYA,QAAMW,IAAI,GAAG,MAAMR,QAAQ,CAACQ,IAAT,EAAnB;;AACA,MAAIR,QAAQ,CAACS,MAAT,KAAoB,GAAxB,EAA6B;AAC3B,QAAID,IAAI,IAAIA,IAAI,CAACE,MAAb,IAAuBF,IAAI,CAACE,MAAL,CAAY,CAAZ,CAAvB,IAAyCF,IAAI,CAACE,MAAL,CAAY,CAAZ,EAAeC,OAA5D,EAAqE;AACnE,YAAO;yBACYH,IAAI,CAACE,MAAL,CAAY,CAAZ,EAAeC,OAAQ;;;EAG9CjB,GAAI;;;EAGJ,gBAAeT,IAAf,EAAqB,IAArB,EAA2B,CAA3B,EAA8B2B,OAA9B,CAAsC,KAAtC,EAA6C,GAA7C,CAAkD;SAPxC,CAQFC,IARE,EAAN;AASD;;AACD,WAAO,IAAP;AACD;;AACD,SAAOL,IAAP;AACD,CApED","sourcesContent":["import config from \"@app/libs/config\";\nimport { checkSession } from \"../user/checkSession\";\n\ninterface opts {\n  useSession?: boolean;\n  debug?: boolean;\n  primaryKey?: string;\n}\n\nexport default async (table: string, data: any, options?: opts) => {\n  const opt = {\n    ...{ useSession: true, debug: false, primaryKey: \"id\" },\n    ...options\n  };\n\n  const postData: any = {};\n  for (let i in data) {\n    if (i === opt.primaryKey || i.endsWith(\"_aggregate\")) {\n      continue;\n    }\n    postData[i] = data[i];\n  }\n\n  const gql = `mutation update($data:${table}_set_input!) {\n    update_${table}(\n      where: {${opt.primaryKey}: {_eq: \"${data[opt.primaryKey]}\"}},\n      _set: $data\n    ) {\n      returning {\n        ${opt.primaryKey}\n      }\n    }\n  }`;\n\n  if (opt && opt.debug) {\n    console.log(gql, data);\n  }\n\n  let headers: any = {\n    \"Content-Type\": \"application/json\"\n  };\n  if (opt.useSession) {\n    const session = await checkSession();\n    headers[\"X-Hasura-Session-Id\"] = session.id;\n    if (!session) {\n      return false;\n    }\n  }\n\n  const response: Response = await fetch(config.url, {\n    method: \"POST\",\n    body: JSON.stringify({\n      operationName: \"update\",\n      query: gql,\n      variables: {\n        data: postData\n      }\n    }),\n    headers\n  });\n\n  const json = await response.json();\n  if (response.status !== 200) {\n    if (json && json.errors && json.errors[0] && json.errors[0].message) {\n      throw `\n(Update Record Failed) ${json.errors[0].message} \n\nGraphQL Mutation:\n${gql}\n\nData: \n${JSON.stringify(data, null, 2).replace(/\"/gi, \"'\")}\n        `.trim();\n    }\n    return null;\n  }\n  return json;\n};\n"]},"metadata":{},"sourceType":"module"}