{"ast":null,"code":"import _Array$isArray from \"@babel/runtime-corejs2/core-js/array/is-array\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport createRecord from \"../queries/crud/createRecord\";\nimport deleteRecord from \"../queries/crud/deleteRecord\";\nimport query from \"../queries/crud/query\";\nimport updateRecord from \"../queries/crud/updateRecord\";\nimport { flow } from \"mobx-state-tree\";\nimport { isLateType, isUnionType, types } from \"mobx-state-tree\";\nexport default (opt => {\n  let primaryKey = !opt.primaryKey ? \"id\" : opt.primaryKey;\n  let columns = {};\n\n  for (let i in opt.columns) {\n    const c = opt.columns[i];\n\n    if (typeof c !== typeof types.maybeNull) {\n      columns[i] = types.maybeNull(c);\n    } else {\n      columns[i] = c;\n    }\n  }\n\n  const recordResult = types.model(_objectSpread({}, columns, {\n    _meta: types.optional(types.string, _JSON$stringify({\n      primaryKey: primaryKey,\n      tableName: opt.tableName\n    })),\n    loading: types.optional(types.boolean, false),\n    errors: types.optional(types.array(types.string), []),\n    isSaved: types.optional(types.boolean, false)\n  })).views(self => ({\n    get isNewRecord() {\n      return !self[primaryKey];\n    },\n\n    get rawData() {\n      const col = _Object$keys(opt.columns);\n\n      const result = {};\n      col.forEach(key => {\n        if (self[key] !== null) {\n          result[key] = self[key];\n        }\n      });\n      return result;\n    }\n\n  })).actions(self => {\n    let actions = {};\n\n    if (opt.actions) {\n      actions = opt.actions(self);\n    }\n\n    return _objectSpread({}, actions, {\n      set: function (key, value) {\n        if (typeof key === \"string\") {\n          self[key] = value;\n\n          if (self[key] !== value) {\n            self.isSaved = false;\n          }\n        } else {\n          for (let i in key) {\n            self[i] = key[i];\n          }\n\n          self.isSaved = false;\n        }\n      },\n      save: flow(function* () {\n        self.validate();\n\n        if (self.errors.length === 0) {\n          if (self.isNewRecord) {\n            self.set(\"loading\", true);\n            const id = yield createRecord(opt.tableName, self.rawData, {\n              primaryKey\n            });\n\n            if (id) {\n              self.set(primaryKey, id);\n              self.set(\"isSaved\", true);\n            }\n\n            self.set(\"loading\", false);\n          } else {\n            yield updateRecord(opt.tableName, self.rawData, {\n              primaryKey\n            });\n          }\n        }\n      }),\n      validate: function () {\n        if (opt.validations) {\n          const validations = opt.validations;\n          const errors = [];\n\n          _Object$keys(validations).forEach(key => {\n            if (validations[key] === \"required\") {\n              if (self[key] === undefined || self[key] === null || self[key] === \"\") {\n                errors.push(`${key} is required.`);\n              }\n            }\n          });\n\n          self.errors = errors;\n        }\n      },\n      load: flow(function* () {\n        if (!self.isNewRecord) {\n          yield self.find({\n            [primaryKey]: self[primaryKey]\n          });\n        }\n      }),\n      find: flow(function* (where, findopt) {\n        self.set(\"loading\", true);\n\n        try {\n          const columns = _Object$keys(opt.columns).map(c => {\n            if (isLateType(opt.columns[c]) || isUnionType(opt.columns[c])) {\n              let query = ``;\n              const col = opt.columns[c];\n              if (col._subType) query = col._subType.properties.query._defaultValue;\n\n              if (_Array$isArray(col._types)) {\n                col._types.forEach(e => {\n                  if (isLateType(e)) {\n                    if (e._subType) {\n                      query = `{ ${e._subType.columns.join(\"\\n\")} }`;\n                    }\n                  }\n                });\n              }\n\n              if (findopt && findopt.query && findopt.query[c]) {\n                query = findopt.query[c];\n              }\n\n              if (query) {\n                return `${c} ${query}`;\n              } else {\n                return ``;\n              }\n            }\n\n            return c;\n          });\n\n          let record = (yield query(opt.tableName, columns, {\n            where\n          })) || {};\n\n          for (let c in record) {\n            const value = record[c];\n\n            if (_Array$isArray(value) && isLateType(opt.columns[c])) {\n              self.set(c, {\n                list: value,\n                loading: false\n              });\n            } else {\n              self.set(c, value);\n            }\n          }\n\n          self.set(\"isSaved\", true);\n          self.set(\"loading\", false);\n        } catch (e) {\n          self.set(\"loading\", false);\n          console.warn(e);\n        }\n      }),\n      delete: flow(function* () {\n        try {\n          const row = yield deleteRecord(opt.tableName, self.rawData, {\n            primaryKey\n          });\n\n          _Object$keys(opt.columns).forEach(c => {\n            if (self[c] !== null) {\n              self.set(c, null);\n            }\n          });\n        } catch (e) {}\n      })\n    });\n  });\n  recordResult.columns = _Object$keys(columns);\n  return recordResult;\n});","map":null,"metadata":{},"sourceType":"module"}